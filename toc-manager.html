<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>TOC Manager (Super)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/favicon.ico" sizes="any" />
  <link rel="icon" type="image/png" href="/favicon.png" />
  <link rel="apple-touch-icon" href="/touch-icon-192x192.png" />
  <link rel="manifest" href="/site.webmanifest" />
<style>
  :root { --pad:12px; --br:10px; --shadow:0 6px 24px rgba(0,0,0,.08); --content-width: 1000px; }
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:0; background:#f7f7f9; color:#111; }
  header { padding:16px 20px; background:#fff; box-shadow: var(--shadow); position:sticky; top:0; z-index:3; }
  .container { max-width: var(--content-width); margin: 0 auto; padding: 0 20px; }
  main { padding: 20px; max-width: var(--content-width); margin: 0 auto; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  input[type="text"], textarea, input[type="url"] { padding:10px 12px; border:1px solid #ddd; border-radius:10px; background:#fff; min-width:280px; }
  button { padding:10px 14px; border-radius:10px; border:1px solid #ddd; background:#fff; cursor:pointer; transition:background .15s ease,border-color .15s ease, color .15s ease; }
  button.primary { background:#2563eb; color:#fff; border-color:#2563eb; box-shadow:0 1px 2px rgba(37,99,235,.2); }
  button.secondary { background:#f3f4f6; color:#374151; border-color:#e5e7eb; }
  section.card { background:#fff; border:1px solid #eee; border-radius:16px; padding:16px; box-shadow: var(--shadow); margin-top:16px; }
  #list { list-style:none; padding:0; margin:0; }
  .item { display:flex; align-items:center; gap:10px; padding:10px; border:1px solid #eee; border-radius:12px; margin-bottom:8px; background:#fff; }
  .item[draggable="true"] { cursor:grab; }
  .dragging { opacity:.5; }
  .pill { font-size:12px; padding:3px 8px; border-radius:999px; border:1px solid #ddd; background:#fafafa; }
  .path { color:#555; font-size:12px; }
  .title-input { flex:1; min-width:160px; }
  .muted { color:#777; }
  .new { outline: 2px dashed #3b82f6; }
  .stale { background: #fff7f7; border-color:#ffdede; }
  details { margin-top:10px; }
  pre.copy { background:#0a0a0a; color:#fff; padding:12px; border-radius:12px; overflow:auto; }
  .grid { display:grid; grid-template-columns: 2fr 1fr; gap:16px; }
  @media (max-width: 1100px){
    .grid { grid-template-columns: 1fr; }
    header .row { flex-wrap: wrap; gap:8px; }
  }
  /* Grouped hierarchy visuals */
  .group { list-style:none; margin:16px 0 6px; padding:0; border:none; }
  .group-title { font-weight:600; padding:6px 8px; border-left:4px solid #e5e7eb; background:#f9fafb; border-radius:8px; display:flex; align-items:center; gap:8px; }
  .group-path { color:#6b7280; font-weight:400; font-size:12px; }
  .item.indent { padding-left:28px; }
  .collapse-btn { border:none; background:transparent; cursor:pointer; font-size:14px; line-height:1; padding:0 4px; }
  .group.collapsed .group-title { background:#eef2ff; }
  .help { margin-top:12px; border-top:1px dashed #e5e7eb; padding-top:12px; color:#374151; font-size:13px; }
  .help h4 { margin:6px 0 8px; font-size:13px; }
  .help ol { margin:0; padding-left:16px; }
  .help li { margin:6px 0; }
  .help .muted { color:#6b7280; }
  /* Instructions styling */
  .steps { list-style:none; padding-left:0; margin:0; }
  .step { display:flex; align-items:flex-start; gap:10px; margin:10px 0; }
  .step .num { width:26px; height:26px; border-radius:999px; background:#2563eb; color:#fff; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:12px; flex:0 0 26px; }
  .subcard { background:#f9fafb; border:1px solid #eef2ff; border-radius:12px; padding:12px 14px; margin:12px 0; }
  .tag { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #e5e7eb; color:#374151; }
  .tag.required { background:#dbeafe; border-color:#bfdbfe; color:#1d4ed8; }
  .tag.optional { background:#f3f4f6; }
  kbd { background:#f3f4f6; border:1px solid #e5e7eb; border-bottom-width:2px; border-radius:6px; padding:0 6px; font-size:12px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .callout { background:#fffbeb; border-left:4px solid #f59e0b; padding:10px 12px; border-radius:8px; }
</style>
</head>
<body>
<header>
  <div class="row container">
  <strong><img src="/touch-icon-192x192.png" alt="App" style="height:32px;width:32px;border-radius:8px;vertical-align:middle;margin-right:10px">TOC Manager</strong>
  <div style="flex:1"></div>
  <button id="loadSitemapBtn" class="primary">Load Sitemap</button>
  <button id="saveSnapshotBtn" class="secondary">Save Snapshot</button>
  <button id="loadSnapshotBtn" class="secondary">Load Snapshot</button>
  <input id="sitemapFile" type="file" accept=".xml,text/xml" style="display:none" />
  </div>
</header>

<main>
  <section class="card grid">
    <div>
      <h3 style="margin-top:0">Pages</h3>
      <p class="muted">Drag to reorder. Toggle <em>Visible</em>. Edit titles. “New” = appears in the sitemap but not in your last <b>snapshot</b>. “Stale” = was in your last <b>snapshot</b> but is no longer in the sitemap.</p>
      <ul id="list"></ul>
    </div>
    <div>
      <div class="row" style="margin-top:0; margin-bottom:16px">
        <button id="showInstructionsBtn" class="secondary" style="width:100%">Instructions</button>
      </div>
      <section class="card" style="margin-top:0">
        <h3 style="margin:0 0 8px 0">
          <img src="/super_logo.svg" alt="Super" style="height:22px;vertical-align:middle;margin-right:6px;"> Integration
        </h3>
        <div class="row">
          <button id="copyHeadBtn" class="secondary">Copy Head</button>
          <button id="copyBodyBtn" class="secondary">Copy Body</button>
          <button id="copyCssBtn" class="secondary">Copy CSS</button>
        </div>
      </section>
      <section class="card" style="margin-top:16px">
        <h3 style="margin:0 0 8px 0">Notion TOC</h3>
        <div class="row">
          <button id="generateMarkdownBtn" class="secondary">Generate Notion TOC</button>
        </div>
        <p class="muted">Create a table of contents for Notion</p>
      </section>
    </div>
  </section>
</main>

<!-- Load Sitemap Modal -->
<div id="sitemapModal" style="position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10;">
  <div style="background:#fff;border-radius:16px;padding:20px;min-width:480px;box-shadow:var(--shadow)">
    <h3 style="margin-top:0">Load Sitemap</h3>
    <p class="muted" style="margin-top:0">Enter a sitemap.xml URL or select a downloaded file.</p>
    <div class="row" style="margin-top:8px">
      <input id="sitemapUrl" type="url" placeholder="https://example.com/sitemap.xml" style="flex:1" />
      <button id="loadUrlBtn" class="primary">Load URL</button>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="loadFileBtn" class="secondary">Choose sitemap.xml…</button>
      <div style="flex:1"></div>
      <button id="cancelSitemapBtn">Cancel</button>
    </div>
  </div>
  
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" style="position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10;">
  <div style="background:#fff;border-radius:16px;padding:20px;max-width:720px;width:90%;box-shadow:var(--shadow)">
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
      <h3 style="margin:0">Instructions</h3>
      <button id="closeInstructionsBtn">Close</button>
    </div>
    <div class="help" style="margin-top:0;border:none;padding-top:0">
      <h4>Typical workflow</h4>
      <ul class="steps">
        <li class="step"><span class="num">1</span><div><b>Load Sitemap</b><br/><span class="muted">Start fresh (URL or file). The workspace is reset to the sitemap’s pages.</span></div></li>
        <li class="step"><span class="num">2</span><div><b>Organize pages</b><br/><span class="muted">Drag modules/lessons, toggle <i>Visible</i>, edit titles.</span></div></li>
        <li class="step"><span class="num">3</span><div><b>Save Snapshot</b> <span class="tag optional">recommended</span><br/><span class="muted">Save <code>manifest.json</code> so your organization is preserved.</span></div></li>
        <li class="step"><span class="num">4</span><div><b>Add code to Super</b><br/>
          <span class="tag required">Copy Head</span>
          <span class="tag optional">Copy Body</span>
          <span class="tag optional">Copy CSS</span>
          <div class="muted">Paste into Super → Code. Head is required; Body/CSS enable the sticky Prev/Next bar.</div>
        </div></li>
      </ul>

      <div class="subcard">
        <h4 style="margin-top:0">Notion TOC</h4>
        <div class="muted">Use <b>Generate Notion TOC</b> to copy a markdown table of contents from your current organization.</div>
        <ul style="margin:8px 0 0 16px">
          <li>In Notion, type <code>&gt; </code> to create a Toggle block for a module.</li>
          <li>Paste the generated list and press <kbd>Tab</kbd> to indent lesson links under the toggle.</li>
        </ul>
      </div>

      <h4>Publish to Super</h4>
      <ul class="steps">
        <li class="step"><span class="num">A</span><div><b>Copy Head</b> <span class="tag required">required</span><br/><span class="muted">Paste into Super → Code → Head to embed the <code>lesson-manifest</code>.</span></div></li>
        <li class="step"><span class="num">B</span><div><b>Copy CSS</b> <span class="tag optional">optional</span><br/><span class="muted">Paste into Super → Code → CSS to style the sticky bar.</span></div></li>
        <li class="step"><span class="num">C</span><div><b>Copy Body</b> <span class="tag optional">optional</span><br/><span class="muted">Paste into Super → Code → Body (end) to activate the sticky bar.</span></div></li>
        <li class="step"><span class="num">D</span><div><b>Publish</b><br/><span class="muted">Publish in Super, then hard refresh your site.</span></div></li>
      </ul>
      <div class="callout" style="margin-top:12px">
        <b>Keep your organization next time</b><br/>
        Save a Snapshot after organizing. Next session, Load Snapshot then Load Sitemap to bring in new pages without losing your order and titles. Re‑copy Head to update the live site.
      </div>
      <p class="muted" style="margin-top:12px">Tip: modules default to collapsed for faster reordering. Click ▸ to expand a module. Drag headers to move whole modules; drag rows to move individual lessons.</p>
    </div>
  </div>
</div>

<!-- Save Snapshot (simple) -->
<div id="saveSnapshotModal" style="position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10;">
  <div style="background:#fff;border-radius:16px;padding:20px;min-width:420px;max-width:520px;width:90%;box-shadow:var(--shadow)">
    <h3 style="margin-top:0">Save Snapshot</h3>
    <p class="muted" style="margin-top:0">Choose where to save <code>manifest.json</code>.</p>
    <div class="row" style="margin-top:8px">
      <button id="saveToDownloadsBtn" class="primary">Save to Downloads</button>
      <button id="saveAsBtn" class="secondary">Save As…</button>
      <div style="flex:1"></div>
      <button id="cancelSaveSnapshotBtn">Cancel</button>
    </div>
  </div>
  
</div>

<!-- Load Snapshot (simple) -->
<div id="loadSnapshotModal" style="position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10;">
  <div style="background:#fff;border-radius:16px;padding:20px;min-width:420px;max-width:520px;width:90%;box-shadow:var(--shadow)">
    <h3 style="margin-top:0">Load Snapshot</h3>
    <p class="muted" style="margin-top:0">Select a previously saved <code>manifest.json</code>.</p>
    <div class="row" style="margin-top:8px">
      <button id="chooseSnapshotBtn" class="primary">Choose from Downloads…</button>
      <div style="flex:1"></div>
      <button id="cancelLoadSnapshotBtn">Cancel</button>
    </div>
  </div>
</div>

<script>
let items = [];
// Remember the last loaded sitemap paths so we can merge after loading a snapshot, regardless of order
let lastSitemapPaths = null;
const key = 'toc-manager-draft';
// Track collapsed state across re-renders
const collapsedGroups = new Set();
let collapsedInitialized = false;

// Helpers
const norm = (u) => {
  try {
    const x = new URL(u, 'https://careforthekids.super.site');
    return (x.pathname.replace(/\/+$/, '') || '/');
  } catch { 
    return null; 
  }
};
const slugTitle = (p) => p === '/' ? 'Home' : decodeURIComponent(p.split('/').pop().replace(/-/g,' ')).replace(/\b\w/g,c=>c.toUpperCase());
const firstSeg = (p) => p === '/' ? '/' : '/' + p.split('/').filter(Boolean)[0];
const depthOf = (p) => (p === '/' ? 0 : p.split('/').filter(Boolean).length);

async function parseSitemapXml(xml) {
  const locs = Array.from(xml.matchAll(/<loc>([^<]+)<\/loc>/g)).map(m => m[1]);
  const normalizedPaths = locs.map(norm).filter(Boolean);
  const uniquePaths = [...new Set(normalizedPaths)];
  return uniquePaths;
}
async function readSitemap(url) {
  const xml = await (await fetch(url, { cache: 'no-store' })).text();
  const paths = await parseSitemapXml(xml);
  lastSitemapPaths = paths;
  return paths;
}

// Reset current working set to exactly the given sitemap paths (clear prior state)
function resetToSitemap(paths){
  try{
    // Normalize input just in case
    const unique = Array.from(new Set((paths||[]).filter(Boolean)));
    items = unique.map(p => ({ path:p, title: slugTitle(p), visible:true, new:false, stale:false }));
    // Reset collapse memory so modules start collapsed by default on first render
    collapsedGroups.clear();
    collapsedInitialized = false;
    render();
    updateButtonStates();
  } catch(err){
    console.error('resetToSitemap error:', err);
    alert('Failed to load sitemap into the workspace: ' + err.message);
  }
}

function mergePaths(paths) {
  try {
    // Ensure items array is initialized
    if (!Array.isArray(items)) items = [];

    // Map of existing items by path (current order is items array order)
    const existingByPath = new Map();
    for (const it of items) if (it && it.path) existingByPath.set(it.path, it);

    const sitemapSet = new Set(paths.filter(Boolean));

    const next = [];

    // 1) Preserve current order for items that still exist in the sitemap
    for (const it of items) {
      if (!it || !it.path) continue;
      if (sitemapSet.has(it.path)) next.push({ ...it, new:false, stale:false });
    }

    // 2) Insert brand-new sitemap paths near their module peers when possible
    for (const p of paths) {
      if (!p || existingByPath.has(p)) continue;
      const newItem = { path:p, title: slugTitle(p), visible:true, new:true, stale:false };
      const group = firstSeg(p);
      let insertAt = -1;
      for (let i = next.length - 1; i >= 0; i--) {
        if (firstSeg(next[i].path) === group) { insertAt = i + 1; break; }
      }
      if (insertAt === -1) next.push(newItem); else next.splice(insertAt, 0, newItem);
    }

    // 3) Append stale items (no longer in sitemap), preserving their prior order
    for (const it of items) {
      if (!it || !it.path) continue;
      if (!sitemapSet.has(it.path)) next.push({ ...it, stale:true });
    }

    items = next;
    render();
    updateButtonStates();
  } catch (error) {
    console.error('Error in mergePaths:', error);
    throw error;
  }
}

function render() {
  try {
    console.log('render() called with items length:', items.length);
    
    const list = document.getElementById('list');
    list.innerHTML = '';

    // Ensure items array is initialized and valid
    if (!Array.isArray(items)) {
      items = [];
    }

    // Filter out invalid items first
    const validItems = items.filter(it => it && typeof it === 'object' && it.path);
    console.log('validItems length after filtering:', validItems.length);
    
    if (validItems.length !== items.length) {
      console.warn('Some items were filtered out:', items.length - validItems.length);
    }
  
  // Group items by their first segment
  const groups = {};
  validItems.forEach((it, i) => {
    const group = firstSeg(it.path);
    if (!groups[group]) groups[group] = [];
    // Use the item's current position in the full list, so reorders stick
    const itemWithIndex = { ...it, originalIndex: i };
    groups[group].push(itemWithIndex);
  });

  // Create a flat list with group headers and items
  const flatList = [];
  Object.keys(groups).forEach(group => {
    if (group !== '/') {
      flatList.push({ type: 'group', group, items: groups[group] });
    } else {
      // Handle root items (no group header)
      groups[group].forEach(item => {
        flatList.push({ type: 'item', item });
      });
    }
  });

  // Initialize default collapsed state once
  if (!collapsedInitialized) {
    Object.keys(groups).forEach(g => { if (g !== '/') collapsedGroups.add(g); });
    collapsedInitialized = true;
  }

  // Render the flat list
  let groupCounter = 0;
  flatList.forEach((entry, flatIndex) => {
    if (entry.type === 'group') {
      const hdr = document.createElement('li');
      hdr.className = 'group';
      hdr.setAttribute('draggable', 'true');
      // Index among groups only (excludes root items)
      const groupIndex = groupCounter++;
      hdr.dataset.flatIndex = flatIndex; // kept for reference
      hdr.dataset.groupIndex = String(groupIndex);
      hdr.dataset.group = entry.group;
      // Collapsible group header with toggle
      hdr.innerHTML = `
        <div class="group-title">
          <button class="collapse-btn" aria-label="Toggle module">▾</button>
          <span class="pill" title="Drag Module">≡</span>
          ${slugTitle(entry.group)}
        </div>
      `;

      // Drag and drop for group headers
      hdr.addEventListener('dragstart', (e) => {
        hdr.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', `group:${groupIndex}:${entry.group}`);
      });
      hdr.addEventListener('dragend', () => hdr.classList.remove('dragging'));
      hdr.addEventListener('dragover', (e) => { 
        // Always allow drop over group headers to enable module reordering
        e.preventDefault();
      });
      hdr.addEventListener('drop', (e) => {
        e.preventDefault();
        const data = e.dataTransfer.getData('text/plain');
        const to = Number(hdr.dataset.groupIndex);
        
        if (data.startsWith('group:')) {
          // Moving a group
          const [, fromStr] = data.split(':');
          const from = Number(fromStr);
          if (Number.isInteger(from) && Number.isInteger(to) && from !== to) {
            moveGroup(from, to);
          }
        }
      });

      list.appendChild(hdr);

      // Container for this group's lessons so we can collapse them cheaply
      const groupContainer = document.createElement('ul');
      groupContainer.className = 'group-items';

      // Add items in this group, skip landing page item at depth 1
      entry.items.filter(it => depthOf(it.path) >= 2).forEach((itemData) => {
        const li = createItemElement(itemData, itemData.originalIndex, flatIndex + 1);
        groupContainer.appendChild(li);
      });
      list.appendChild(groupContainer);

      // Make the whole header the drag handle; prevent text selection issues
      hdr.addEventListener('mousedown', () => {
        hdr.draggable = true;
      });

      // Toggle collapse/expand
      const toggleBtn = hdr.querySelector('.collapse-btn');
      toggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isCollapsed = hdr.classList.toggle('collapsed');
        toggleBtn.textContent = isCollapsed ? '▸' : '▾';
        groupContainer.style.display = isCollapsed ? 'none' : '';
        if (isCollapsed) collapsedGroups.add(entry.group); else collapsedGroups.delete(entry.group);
      });

      // Respect stored collapse state
      if (collapsedGroups.has(entry.group)) {
        hdr.classList.add('collapsed');
        toggleBtn.textContent = '▸';
        groupContainer.style.display = 'none';
      } else {
        toggleBtn.textContent = '▾';
        groupContainer.style.display = '';
      }
    } else {
      // Individual item (root level)
      const li = createItemElement(entry.item, entry.item.originalIndex ?? flatIndex, flatIndex);
      list.appendChild(li);
    }
  });

  // keep manifest in memory only
  updateButtonStates();
  } catch (error) {
    console.error('Error in render():', error);
    throw error;
  }
}

function createItemElement(item, originalIndex, flatIndex) {
  const li = document.createElement('li');
  const depth = depthOf(item.path);
  li.className = 'item' + (item.new ? ' new' : '') + (item.stale ? ' stale' : '') + (depth >= 2 ? ' indent' : '');
  li.setAttribute('draggable', 'true');
  li.dataset.index = originalIndex;
  li.dataset.flatIndex = flatIndex;

  li.innerHTML = `
    <span class="pill" title="Drag">≡</span>
    <input type="checkbox" ${item.visible ? 'checked' : ''} class="vis" title="Visible" />
    <input type="text" value="${item.title}" class="title-input" />
  `;

  // Drag and drop for items
  li.addEventListener('dragstart', (e) => {
    li.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', `item:${flatIndex}:${originalIndex}`);
  });
  li.addEventListener('dragend', () => li.classList.remove('dragging'));
  li.addEventListener('dragover', (e) => { 
    if (e.currentTarget.classList.contains('group') || e.currentTarget.classList.contains('item')) {
      e.preventDefault(); 
    }
  });
  li.addEventListener('drop', (e) => {
    e.preventDefault();
    const data = e.dataTransfer.getData('text/plain');
    const toFlat = Number(li.dataset.flatIndex);
    const toOriginalIndex = Number(li.dataset.index);
    
    if (data.startsWith('group:')) {
      // Moving a group to an item position
      const [, fromStr, group] = data.split(':');
      const from = Number(fromStr);
      if (Number.isInteger(from) && Number.isInteger(toFlat) && from !== toFlat) {
        moveGroup(from, toFlat);
      }
    } else if (data.startsWith('item:')) {
      // Moving an item
      const [, fromStr, originalFromIndex] = data.split(':');
      const from = Number(fromStr);
      const fromIndex = Number(originalFromIndex);
      if (Number.isInteger(fromIndex) && Number.isInteger(toOriginalIndex) && fromIndex !== toOriginalIndex) {
        const moving = items.splice(fromIndex, 1)[0];
        const insertAt = fromIndex < toOriginalIndex ? toOriginalIndex - 1 : toOriginalIndex;
        items.splice(Math.max(0, Math.min(insertAt, items.length)), 0, moving);
        render();
      }
    }
  });

  li.querySelector('.vis').addEventListener('change', (e) => { item.visible = e.target.checked; preview(); });
  li.querySelector('.title-input').addEventListener('input', (e) => { item.title = e.target.value; preview(); });

  return li;
}

function moveGroup(fromGroupIndex, toGroupIndex) {
  // Build ordered list of group keys (excluding root '/')
  const groupsMap = {};
  items.forEach((it) => {
    const g = firstSeg(it.path);
    if (!groupsMap[g]) groupsMap[g] = [];
    groupsMap[g].push(it);
  });

  const groupOrder = Object.keys(groupsMap).filter(g => g !== '/');
  if (fromGroupIndex < 0 || fromGroupIndex >= groupOrder.length) return;

  const [movedGroupKey] = groupOrder.splice(fromGroupIndex, 1);
  // Insert BEFORE the target index. If moving down, account for removed slot.
  let insertAt = toGroupIndex;
  if (fromGroupIndex < toGroupIndex) insertAt = Math.max(0, toGroupIndex - 1);
  insertAt = Math.min(Math.max(insertAt, 0), groupOrder.length);
  groupOrder.splice(insertAt, 0, movedGroupKey);

  // Rebuild items with root items first, then groups in new order
  const rebuilt = [];
  (groupsMap['/'] || []).forEach(it => rebuilt.push(it));
  groupOrder.forEach(key => {
    (groupsMap[key] || []).forEach(it => rebuilt.push(it));
  });

  items = rebuilt;
  render();
}

function moveItemToGroup(fromFlatIndex, toFlatIndex) {
  // This function would handle moving an individual item to a different group
  // For now, we'll just do a simple item reorder
  const fromIndex = Number(document.querySelector(`[data-flat-index="${fromFlatIndex}"]`).dataset.index);
  const toIndex = Number(document.querySelector(`[data-flat-index="${toFlatIndex}"]`).dataset.index);
  
  if (Number.isInteger(fromIndex) && Number.isInteger(toIndex) && fromIndex !== toIndex) {
    const m = items.splice(fromIndex, 1)[0];
    items.splice(toIndex, 0, m);
    render();
  }
}

function buildManifestFromItems(){
  const validItems = (Array.isArray(items) ? items : []).filter(x => x && typeof x === 'object' && x.path);
  const linear_order = validItems.filter(x => x.visible).map(x => x.path);
  const meta = {};
  for (const x of validItems) {
    meta[x.path] = { title: x.title, visible: !!x.visible };
  }
  return { version: 1, generated_at: new Date().toISOString(), linear_order, meta };
}

// Enable/disable buttons based on state
function updateButtonStates(){
  const hasItems = Array.isArray(items) && items.length > 0;
  const setState = (id, active) => {
    const el = document.getElementById(id);
    if(!el) return;
    el.classList.toggle('primary', !!active);
    el.classList.toggle('secondary', !active);
  };
  setState('saveSnapshotBtn', hasItems);
  setState('copyHeadBtn', hasItems);
  setState('copyBodyBtn', hasItems);
  setState('copyCssBtn', hasItems);
  setState('generateMarkdownBtn', hasItems);
  // Always active
  const loadBtn = document.getElementById('loadSitemapBtn');
  if (loadBtn) { loadBtn.classList.add('primary'); loadBtn.classList.remove('secondary'); }
}

function download(filename, text) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type:'application/json'}));
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
}

// Prefer modern file save so the user can choose Downloads
async function saveManifestFile(defaultName, text) {
  try {
    if (window.showSaveFilePicker) {
      const handle = await window.showSaveFilePicker({
        suggestedName: defaultName,
        types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
      });
      const writable = await handle.createWritable();
      await writable.write(text);
      await writable.close();
      alert('manifest.json saved.');
      return;
    }
  } catch (e) {
    // If the user cancels, just return silently
    if (e && e.name === 'AbortError') return;
    // fall back to legacy download if picker fails
  }
  download(defaultName, text);
}

// Notion TOC from manifest/items
function generateNotionTOC(){
  if (!Array.isArray(items)) return '';
  const visible = items.filter(x => x && x.visible !== false);
  const groups = {};
  visible.forEach(it=>{ const g = firstSeg(it.path); (groups[g]||(groups[g]=[])).push(it); });
  let md = '# Table of Contents\n\n';
  Object.keys(groups).forEach(group=>{
    if(group==='/' ){
      groups[group].forEach(it=>{ md += `- [${it.title}](${it.path})\n`; });
      md += '\n';
    } else {
      md += `> ${slugTitle(group)}\n`;
      groups[group].forEach(it=>{ md += `- [${it.title}](${it.path})\n`; });
      md += '\n';
    }
  });
  return md;
}

// Events

// Open modal to load sitemap
document.getElementById('loadSitemapBtn').addEventListener('click', () => {
  document.getElementById('sitemapModal').style.display = 'flex';
});
document.getElementById('sitemapFile').addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  try {
    const xml = await f.text();
    console.log('Parsing sitemap file...');
    const paths = await parseSitemapXml(xml);
    console.log('Parsed paths:', paths);
    // Clear current state and reset to the sitemap only
    resetToSitemap(paths);
  } catch (err) {
    console.error('Sitemap parsing error:', err);
    alert('Could not parse sitemap.xml: ' + err.message);
  }
  e.target.value = '';
});

// Modal actions
document.getElementById('cancelSitemapBtn').addEventListener('click', ()=>{
  document.getElementById('sitemapModal').style.display = 'none';
});
document.getElementById('loadUrlBtn').addEventListener('click', async ()=>{
  const url = document.getElementById('sitemapUrl').value.trim();
  if(!url){ alert('Please enter a sitemap URL.'); return; }
  try { const paths = await readSitemap(url); resetToSitemap(paths); document.getElementById('sitemapModal').style.display='none'; }
  catch(e){ alert('Failed to load sitemap: '+e.message); }
});
document.getElementById('loadFileBtn').addEventListener('click', ()=>{
  document.getElementById('sitemapFile').click();
});

// Save/Load Snapshot (simple modal flow)
document.getElementById('saveSnapshotBtn').addEventListener('click', () => {
  document.getElementById('saveSnapshotModal').style.display='flex';
});
document.getElementById('cancelSaveSnapshotBtn').addEventListener('click', ()=>{
  document.getElementById('saveSnapshotModal').style.display='none';
});
document.getElementById('saveToDownloadsBtn').addEventListener('click', async ()=>{
  try{
    const man = buildManifestFromItems();
    const blob = new Blob([JSON.stringify(man, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'manifest.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
    alert('Snapshot saved to Downloads.');
  } finally {
    document.getElementById('saveSnapshotModal').style.display='none';
  }
});
document.getElementById('saveAsBtn').addEventListener('click', async ()=>{
  try{
    const man = buildManifestFromItems();
    await saveManifestFile('manifest.json', JSON.stringify(man, null, 2));
  } finally {
    document.getElementById('saveSnapshotModal').style.display='none';
  }
});

document.getElementById('loadSnapshotBtn').addEventListener('click', () => {
  document.getElementById('loadSnapshotModal').style.display='flex';
});
document.getElementById('cancelLoadSnapshotBtn').addEventListener('click', ()=>{
  document.getElementById('loadSnapshotModal').style.display='none';
});
document.getElementById('chooseSnapshotBtn').addEventListener('click', async ()=>{
  try{
    if (window.showOpenFilePicker) {
      const [handle] = await window.showOpenFilePicker({ types:[{ description:'JSON', accept:{ 'application/json':['.json'] } }] });
      const file = await handle.getFile();
      const text = await file.text();
      const man = JSON.parse(text);
      const meta = man.meta || {};
      const order = Array.isArray(man.linear_order) ? man.linear_order : [];
      const fromManifest = order.map(p => ({ path:p, title: meta[p]?.title || slugTitle(p), visible: meta[p]?.visible !== false, new:false, stale:false }));
      for(const p of Object.keys(meta)) if(!fromManifest.find(x=>x.path===p)){
        fromManifest.push({ path:p, title: meta[p]?.title || slugTitle(p), visible: meta[p]?.visible !== false, new:false, stale:false });
      }
      // If a sitemap is currently remembered, apply snapshot organization to sitemap
      if (Array.isArray(lastSitemapPaths) && lastSitemapPaths.length) {
        items = fromManifest;
        mergePaths(lastSitemapPaths);
      } else {
        // No sitemap yet—just show the snapshot contents
        items = fromManifest;
        render();
      }
      updateButtonStates();
    } else {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async (e)=>{
        const file = e.target.files[0]; if(!file) return;
        const text = await file.text();
        const man = JSON.parse(text);
        const meta = man.meta || {};
        const order = Array.isArray(man.linear_order) ? man.linear_order : [];
        const fromManifest = order.map(p => ({ path:p, title: meta[p]?.title || slugTitle(p), visible: meta[p]?.visible !== false, new:false, stale:false }));
        for(const p of Object.keys(meta)) if(!fromManifest.find(x=>x.path===p)){
          fromManifest.push({ path:p, title: meta[p]?.title || slugTitle(p), visible: meta[p]?.visible !== false, new:false, stale:false });
        }
        if (Array.isArray(lastSitemapPaths) && lastSitemapPaths.length) {
          items = fromManifest;
          mergePaths(lastSitemapPaths);
        } else {
          items = fromManifest;
          render();
        }
        updateButtonStates();
      };
      input.click();
    }
  } finally {
    document.getElementById('loadSnapshotModal').style.display='none';
  }
});

document.getElementById('copyHeadBtn').addEventListener('click', async () => {
  const man = buildManifestFromItems();
  const text = '<script id="lesson-manifest" type="application/json">' + JSON.stringify(man) + '</' + 'script>';
  try {
    await navigator.clipboard.writeText(text);
    alert('Copied <script> to clipboard. Paste into Super → Code → Head.');
  } catch {
    alert('Copy failed—please select and copy manually.');
  }
});

// Notion TOC generation
document.getElementById('generateMarkdownBtn').addEventListener('click', async ()=>{
  const md = generateNotionTOC();
  try{ await navigator.clipboard.writeText(md); alert('Notion TOC copied to clipboard! Paste it into Notion.'); }
  catch{ alert('Copy failed—please select and copy manually.'); }
});

// Instructions modal
document.getElementById('showInstructionsBtn').addEventListener('click', ()=>{
  document.getElementById('instructionsModal').style.display='flex';
});
document.getElementById('closeInstructionsBtn').addEventListener('click', ()=>{
  document.getElementById('instructionsModal').style.display='none';
});
</script>
<script>
// ----- Sticky footer snippets (copy helpers) -----
function stickyCSS() {
  return `html{scroll-padding-bottom:72px}
#lesson-nav{position:fixed;left:0;right:0;bottom:0;z-index:9999;display:none;justify-content:space-between;align-items:center;padding:10px 16px;background:rgba(255,255,255,.92);backdrop-filter:blur(6px);border-top:1px solid #e5e5e5;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
#lesson-nav a{padding:8px 12px;border:1px solid #ddd;border-radius:8px;text-decoration:none}
#lesson-nav .spacer{flex:1}`;
}
function stickyBodyHTML(){
  return `<div id="lesson-nav"><a id="prev-link" aria-label="Previous">← Previous</a><div class="spacer"></div><a id="next-link" aria-label="Next">Next →</a></div>`;
}
function stickyBodyJS(){
  const js = "(()=>{const el=document.getElementById('lesson-manifest');if(!el)return;let man;try{man=JSON.parse(el.textContent)}catch(e){return}const order=(man.linear_order||[]).filter(Boolean);const norm=p=>{try{const x=new URL(p,location.origin);return x.pathname.replace(/\\/\\/+$/,'')||'/'}catch{return null}};const here=norm(location.pathname);const idx=order.indexOf(here);if(idx<0)return;const prev=order[idx-1],next=order[idx+1];const bar=document.getElementById('lesson-nav');const p=document.getElementById('prev-link');const n=document.getElementById('next-link');if(prev){p.href=prev;p.style.visibility='visible'}else{p.style.visibility='hidden'}if(next){n.href=next;n.style.visibility='visible'}else{n.style.visibility='hidden'}bar.style.display='flex'})();";
  return '<script>\n'+js+'\n</'+'script>';
}
async function copy(txt){try{await navigator.clipboard.writeText(txt);alert('Copied to clipboard.')}catch{alert('Copy failed — please select and copy manually.')}}

// Copy buttons
document.getElementById('copyCssBtn').addEventListener('click', ()=>copy(stickyCSS()));
document.getElementById('copyBodyBtn').addEventListener('click', ()=>copy(stickyBodyHTML()+"\n"+stickyBodyJS()));
</script>
</body>
</html>
